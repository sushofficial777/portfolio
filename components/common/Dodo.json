{
    "uniforms": {
      "u_size": 1,
      "u_amount": 0.441,
      "u_vignette": 0,
      "u_opacity_random": true,
      "u_random_seed": 0.5222752078994444,
      "u_shape": [
        false,
        true,
        false,
        false,
        false,
        false,
        false
      ],
      "u_shape_image": null,
      "u_rotation": 0,
      "u_rotation_random": false,
      "u_color_random": false,
      "u_aa_passes": 2
    },
    "fragmentShader": "\n\n    uniform vec2 u_resolution;\n\n    uniform vec3 u_color; //random:true\n\n    uniform bool u_color_random; //ignore:true\n\n    uniform float u_size; //units:px, min:1, max: 256, step:1\n\n    uniform float u_vignette; //units:%, step:0.001\n\n    uniform float u_amount; //units:%\n\n    uniform bool u_opacity_random; //ignore:true\n\n    uniform float u_rotation; //units:Â°, min:0, max:360, step:1, random:true\n\n    uniform bool u_rotation_random; //ignore:true\n\n    uniform bool u_shape[7];\n\n    uniform sampler2D u_shape_image;\n\n    uniform vec2 u_shape_image_resolution; //ignore:true\n\n    uniform float u_random_seed; //ignore:true\n\n    uniform float u_aa_passes; //ignore:true\n\n\n\n    float vignette(float amount){\n\n          vec2 position = (gl_FragCoord.xy / u_resolution) - vec2(0.5);\n\n          float dist = length(position * vec2(u_resolution.x/u_resolution.y, 1.0));\n\n\n\n          float radius = 1.0*amount;\n\n          float softness = 1.0-radius;\n\n          float v = smoothstep(radius, radius - softness, dist);\n\n\n\n          return v;\n\n      }\n\n\n\n    float aspectScale(inout vec2 st,float xRes, float yRes){\n\n        float aspect = xRes/yRes;\n\n        float diff = (1.0 - aspect)/2.0;\n\n        float vis = 1.0;\n\n\n\n        if(aspect > 1.){\n\n        st.y *= aspect;\n\n        st.y += diff;\n\n        vis = (1.0 - step(1.0,st.y)) * (step(0.0,st.y)) * (1.0 - step(1.0,st.x)) * (step(0.0,st.x));\n\n        } else {\n\n            st.x *= yRes/xRes;\n\n            st.x += (1.0 - yRes/xRes)/2.0;\n\n            vis = (1.0 - step(1.0,st.x)) *(step(0.0,st.x)) * (1.0 - step(1.0,st.y)) *(step(0.0,st.y));\n\n        }\n\n        return vis;\n\n    }\n\n\n\n    highp float rand(vec2 co)\n\n    {\n\n        highp float a = 12.9898;\n\n        highp float b = 78.233;\n\n        highp float c = 43758.5453;\n\n        highp float dt= dot(co.xy ,vec2(a,b));\n\n        highp float sn= mod(dt,3.14);\n\n        return fract(sin(sn) * c);\n\n    }\n\n\n\n    #ifndef PI\n\n    #define PI 3.1415926535897932384626433832795\n\n    #endif\n\n\n\n\n\n\n#ifndef FNC_AASTEP\n#define FNC_AASTEP\n#if defined(GL_OES_standard_derivatives)\n#extension GL_OES_standard_derivatives : enable\n#endif\nfloat aastep(float threshold, float value) {\n#if !defined(GL_ES) || __VERSION__ >= 300 || defined(GL_OES_standard_derivatives)\n    float afwidth = 0.7 * length(vec2(dFdx(value), dFdy(value)));\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n#elif defined(AA_EDGE)\n    float afwidth = AA_EDGE;\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n#else \n    return step(threshold, value);\n#endif\n}\n#endif\n\n#ifndef FNC_FILL\n#define FNC_FILL\nfloat fill(float x, float size, float edge) {\n    return 1.0 - smoothstep(size - edge, size + edge, x);\n}\nfloat fill(float x, float size) {\n    return 1.0 - aastep(size, x);\n}\n#endif\n\n\n\n\n#ifndef FNC_TRISDF\n#define FNC_TRISDF\nfloat triSDF(in vec2 st) {\n#ifdef CENTER_2D\n    st -= CENTER_2D;\n    st *= 5.0;\n#else\n    st -= 0.5;\n    st *= 5.0;\n#endif\n    return max(abs(st.x) * .866025 + st.y * .5, -st.y * 0.5);\n}\n#endif\n\n\n\n\n#ifndef FNC_HEXSDF\n#define FNC_HEXSDF\nfloat hexSDF(in vec2 st) {\n#ifdef CENTER_2D\n    st -= CENTER_2D;\n    st *= 2.0;\n#else\n    st = st * 2.0 - 1.0;\n#endif\n    st = abs(st);\n    return max(abs(st.y), st.x * .866025 + st.y * .5);\n}\n#endif\n\n\n\n#ifndef QTR_PI\n#define QTR_PI 0.78539816339\n#endif\n#ifndef HALF_PI\n#define HALF_PI 1.5707963267948966192313216916398\n#endif\n#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n#ifndef TWO_PI\n#define TWO_PI 6.2831853071795864769252867665590\n#endif\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n#ifndef INV_PI\n#define INV_PI 0.31830988618379067153776752674503\n#endif\n#ifndef INV_SQRT_TAU\n#define INV_SQRT_TAU 0.39894228040143267793994605993439  \n#endif\n#ifndef SQRT_HALF_PI\n#define SQRT_HALF_PI 1.25331413732\n#endif\n#ifndef PHI\n#define PHI 1.618033988749894848204586834\n#endif\n#ifndef EPSILON\n#define EPSILON 0.0000001\n#endif\n#ifndef GOLDEN_RATIO\n#define GOLDEN_RATIO 1.6180339887\n#endif\n#ifndef GOLDEN_RATIO_CONJUGATE \n#define GOLDEN_RATIO_CONJUGATE 0.61803398875\n#endif\n#ifndef GOLDEN_ANGLE \n#define GOLDEN_ANGLE 2.39996323\n#endif\n\n\n#ifndef FNC_SCALE\n#define FNC_SCALE\nvec2 scale(in float st, in float s, in vec2 center) { return (st - center) * s + center; }\nvec2 scale(in float st, in float s) {\n#ifdef CENTER_2D\n    return scale(st,  s, CENTER_2D);\n#else\n    return scale(st,  s, vec2(0.5));\n#endif\n}\nvec2 scale(in vec2 st, in vec2 s, in vec2 center) { return (st - center) * s + center; }\nvec2 scale(in vec2 st, in float s, in vec2 center) { return scale(st, vec2(s), center); }\nvec2 scale(in vec2 st, in vec2 s) {\n#ifdef CENTER_2D\n    return (st - CENTER_2D) * s + CENTER_2D;\n#else\n    return (st - 0.5) * s + 0.5;\n#endif\n}\nvec2 scale(in vec2 st, in float s) {\n#ifdef CENTER_2D\n    return (st - CENTER_2D) * s + CENTER_2D;\n#else\n    return (st - 0.5) * s + 0.5;\n#endif\n}\nvec3 scale(in vec3 st, in vec3 s, in vec3 center) { return (st - center) * s + center; }\nvec3 scale(in vec3 st, in float s, in vec3 center) { return (st - center) * s + center; }\nvec3 scale(in vec3 st, in vec3 s) {\n#ifdef CENTER_3D\n    return (st - CENTER_3D) * s + CENTER_3D;\n#else\n    return (st - 0.5) * s + 0.5;\n#endif\n}\nvec3 scale(in vec3 st, in float s) {\n#ifdef CENTER_3D\n    return (st - CENTER_3D) * s + CENTER_3D;\n#else\n    return (st - 0.5) * s + 0.5;\n#endif\n}\n\nvec4 scale(in vec4 st, float s) { return vec4(scale(st.xy, s), st.zw); }\nvec4 scale(in vec4 st, vec2 s) { return vec4(scale(st.xy, s), st.zw); }\n#endif\n\n\n#ifndef FNC_STARSDF\n#define FNC_STARSDF\nfloat starSDF(in vec2 st, in int V, in float s) {\n#ifdef CENTER_2D\n    st -= CENTER_2D;\n#else\n    st -= 0.5;\n#endif\n    st *= 2.0;\n    float a = atan(st.y, st.x) / TAU;\n    float seg = a * float(V);\n    a = ((floor(seg) + 0.5) / float(V) +\n        mix(s, -s, step(0.5, fract(seg))))\n        * TAU;\n    return abs(dot(vec2(cos(a), sin(a)),\n                   st));\n}\nfloat starSDF(in vec2 st, in int V) {\n    return starSDF( scale(st, 12.0/float(V)), V, 0.1);\n}\n#endif\n\n\n\n\n#ifndef FNC_RECTSDF\n#define FNC_RECTSDF\nfloat rectSDF(vec2 p, vec2 b, float r) {\n    vec2 d = abs(p - 0.5) * 4.2 - b + vec2(r);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - r;   \n}\nfloat rectSDF(vec2 p, float b, float r) {\n    return rectSDF(p, vec2(b), r);\n}\nfloat rectSDF(in vec2 st, in vec2 s) {\n    #ifdef CENTER_2D\n        st -= CENTER_2D;\n        st *= 2.0;\n    #else\n        st = st * 2.0 - 1.0;\n    #endif\n    return max( abs(st.x / s.x),\n                abs(st.y / s.y) );\n}\nfloat rectSDF(in vec2 st, in float s) {\n    return rectSDF(st, vec2(s) );\n}\nfloat rectSDF(in vec2 st) {\n    return rectSDF(st, vec2(1.0));\n}\n#endif\n\n\n\n#ifndef QTR_PI\n#define QTR_PI 0.78539816339\n#endif\n#ifndef HALF_PI\n#define HALF_PI 1.5707963267948966192313216916398\n#endif\n#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n#ifndef TWO_PI\n#define TWO_PI 6.2831853071795864769252867665590\n#endif\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n#ifndef INV_PI\n#define INV_PI 0.31830988618379067153776752674503\n#endif\n#ifndef INV_SQRT_TAU\n#define INV_SQRT_TAU 0.39894228040143267793994605993439  \n#endif\n#ifndef SQRT_HALF_PI\n#define SQRT_HALF_PI 1.25331413732\n#endif\n#ifndef PHI\n#define PHI 1.618033988749894848204586834\n#endif\n#ifndef EPSILON\n#define EPSILON 0.0000001\n#endif\n#ifndef GOLDEN_RATIO\n#define GOLDEN_RATIO 1.6180339887\n#endif\n#ifndef GOLDEN_RATIO_CONJUGATE \n#define GOLDEN_RATIO_CONJUGATE 0.61803398875\n#endif\n#ifndef GOLDEN_ANGLE \n#define GOLDEN_ANGLE 2.39996323\n#endif\n\n\n#ifndef FNC_SCALE\n#define FNC_SCALE\nvec2 scale(in float st, in float s, in vec2 center) { return (st - center) * s + center; }\nvec2 scale(in float st, in float s) {\n#ifdef CENTER_2D\n    return scale(st,  s, CENTER_2D);\n#else\n    return scale(st,  s, vec2(0.5));\n#endif\n}\nvec2 scale(in vec2 st, in vec2 s, in vec2 center) { return (st - center) * s + center; }\nvec2 scale(in vec2 st, in float s, in vec2 center) { return scale(st, vec2(s), center); }\nvec2 scale(in vec2 st, in vec2 s) {\n#ifdef CENTER_2D\n    return (st - CENTER_2D) * s + CENTER_2D;\n#else\n    return (st - 0.5) * s + 0.5;\n#endif\n}\nvec2 scale(in vec2 st, in float s) {\n#ifdef CENTER_2D\n    return (st - CENTER_2D) * s + CENTER_2D;\n#else\n    return (st - 0.5) * s + 0.5;\n#endif\n}\nvec3 scale(in vec3 st, in vec3 s, in vec3 center) { return (st - center) * s + center; }\nvec3 scale(in vec3 st, in float s, in vec3 center) { return (st - center) * s + center; }\nvec3 scale(in vec3 st, in vec3 s) {\n#ifdef CENTER_3D\n    return (st - CENTER_3D) * s + CENTER_3D;\n#else\n    return (st - 0.5) * s + 0.5;\n#endif\n}\nvec3 scale(in vec3 st, in float s) {\n#ifdef CENTER_3D\n    return (st - CENTER_3D) * s + CENTER_3D;\n#else\n    return (st - 0.5) * s + 0.5;\n#endif\n}\n\nvec4 scale(in vec4 st, float s) { return vec4(scale(st.xy, s), st.zw); }\nvec4 scale(in vec4 st, vec2 s) { return vec4(scale(st.xy, s), st.zw); }\n#endif\n\n\n#ifndef FNC_STARSDF\n#define FNC_STARSDF\nfloat starSDF(in vec2 st, in int V, in float s) {\n#ifdef CENTER_2D\n    st -= CENTER_2D;\n#else\n    st -= 0.5;\n#endif\n    st *= 2.0;\n    float a = atan(st.y, st.x) / TAU;\n    float seg = a * float(V);\n    a = ((floor(seg) + 0.5) / float(V) +\n        mix(s, -s, step(0.5, fract(seg))))\n        * TAU;\n    return abs(dot(vec2(cos(a), sin(a)),\n                   st));\n}\nfloat starSDF(in vec2 st, in int V) {\n    return starSDF( scale(st, 12.0/float(V)), V, 0.1);\n}\n#endif\n\n\n\n\n#ifndef CIRCLESDF_FNC\n#define CIRCLESDF_FNC(POS_UV) length(POS_UV)\n#endif\n#ifndef FNC_CIRCLESDF\n#define FNC_CIRCLESDF\nfloat circleSDF(in vec2 v) {\n#ifdef CENTER_2D\n    v -= CENTER_2D;\n#else\n    v -= 0.5;\n#endif\n    return CIRCLESDF_FNC(v) * 2.0;\n}\n#endif\n\n\n\n\n#if !defined(FNC_SATURATE) && !defined(saturate)\n#define FNC_SATURATE\n#define saturate(V) clamp(V, 0.0, 1.0)\n#endif\n\n#ifndef FNC_LINESDF\n#define FNC_LINESDF\nfloat lineSDF( in vec2 st, in vec2 a, in vec2 b ) {\n    vec2 b_to_a = b - a;\n    vec2 to_a = st - a;\n    float h = saturate(dot(to_a, b_to_a)/dot(b_to_a, b_to_a));\n    return length(to_a - h * b_to_a );\n}\nfloat lineSDF(vec3 p, vec3 a, vec3 b) {\n    \n    return length(cross(p - a, p - b))/length(b - a);\n}\n#endif\n\n\n\n\n#ifndef FNC_RECTSDF\n#define FNC_RECTSDF\nfloat rectSDF(vec2 p, vec2 b, float r) {\n    vec2 d = abs(p - 0.5) * 4.2 - b + vec2(r);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - r;   \n}\nfloat rectSDF(vec2 p, float b, float r) {\n    return rectSDF(p, vec2(b), r);\n}\nfloat rectSDF(in vec2 st, in vec2 s) {\n    #ifdef CENTER_2D\n        st -= CENTER_2D;\n        st *= 2.0;\n    #else\n        st = st * 2.0 - 1.0;\n    #endif\n    return max( abs(st.x / s.x),\n                abs(st.y / s.y) );\n}\nfloat rectSDF(in vec2 st, in float s) {\n    return rectSDF(st, vec2(s) );\n}\nfloat rectSDF(in vec2 st) {\n    return rectSDF(st, vec2(1.0));\n}\n#endif\n\n\n#ifndef FNC_CROSSSDF\n#define FNC_CROSSSDF\nfloat crossSDF(in vec2 st, in float s) {\n    vec2 size = vec2(.25, s);\n    return min(rectSDF(st.xy, size.xy),\n               rectSDF(st.xy, size.yx));\n}\n#endif\n\n\n\n\n#ifndef FNC_ROTATE2D\n#define FNC_ROTATE2D\nmat2 rotate2d(in float r){\n    float c = cos(r);\n    float s = sin(r);\n    return mat2(c, -s, s, c);\n}\n#endif\n\n\n#ifndef FNC_ROTATE4D\n#define FNC_ROTATE4D\nmat4 rotate4d(in vec3 a, in float r) {\n    a = normalize(a);\n    float s = sin(r);\n    float c = cos(r);\n    float oc = 1.0 - c;\n    return mat4(oc * a.x * a.x + c,           oc * a.x * a.y - a.z * s,  oc * a.z * a.x + a.y * s,  0.0,\n                oc * a.x * a.y + a.z * s,  oc * a.y * a.y + c,           oc * a.y * a.z - a.x * s,  0.0,\n                oc * a.z * a.x - a.y * s,  oc * a.y * a.z + a.x * s,  oc * a.z * a.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n#endif\n\n\n#ifndef FNC_ROTATE\n#define FNC_ROTATE\nvec2 rotate(in vec2 v, in float r, in vec2 c) {\n    return rotate2d(r) * (v - c) + c;\n}\nvec2 rotate(in vec2 v, in float r) {\n    #ifdef CENTER_2D\n    return rotate(v, r, CENTER_2D);\n    #else\n    return rotate(v, r, vec2(.5));\n    #endif\n}\nvec2 rotate(vec2 v, vec2 x_axis) {\n    #ifdef CENTER_2D\n    v -= CENTER_2D;\n    #endif\n    vec2 rta = vec2( dot(v, vec2(-x_axis.y, x_axis.x)), dot(v, x_axis) );\n    #ifdef CENTER_2D\n    rta += CENTER_2D;\n    #endif\n    return rta;\n}\nvec3 rotate(in vec3 v, in float r, in vec3 axis, in vec3 c) {\n    return (rotate4d(axis, r) * vec4(v - c, 1.)).xyz + c;\n}\nvec3 rotate(in vec3 v, in float r, in vec3 axis) {\n    #ifdef CENTER_3D\n    return rotate(v, r, axis, CENTER_3D);\n    #else\n    return rotate(v, r, axis, vec3(0.));\n    #endif\n}\nvec4 rotate(in vec4 v, in float r, in vec3 axis, in vec4 c) {\n    return rotate4d(axis, r) * (v - c) + c;\n}\nvec4 rotate(in vec4 v, in float r, in vec3 axis) {\n    #ifdef CENTER_4D\n    return rotate(v, r, axis, CENTER_4D);\n    #else\n    return rotate(v, r, axis, vec4(0.));\n    #endif\n}\n#if defined(FNC_QUATMULT)\nvec3 rotate(QUAT q, vec3 v) {\n    QUAT q_c = QUAT(-q.x, -q.y, -q.z, q.w);\n    return quatMul(q, quatMul(vec4(v, 0), q_c)).xyz;\n}\nvec3 rotate(QUAT q, vec3 v, vec3 c) {\n    vec3 dir = v - c;\n    return c + rotate(q, dir);\n}\n#endif\n#endif\n\n\n\n    vec3 hash3D(vec2 x)\n\n    {\n\n        // based on: pcg3 by Mark Jarzynski: http://www.jcgt.org/published/0009/03/02/\n\n        uvec3 v = uvec3(x.xyx * 65536.0) * 1664525u + 1013904223u;\n\n        v += v.yzx * v.zxy;\n\n        v ^= v >> 16u;\n\n\n\n        v.x += v.y * v.z;\n\n        v.y += v.z * v.x;\n\n        v.z += v.x * v.y;\n\n        return vec3(v) * (1.0 / float(0xffffffffu));\n\n    }\n\n    \n\n    void staticNoise(vec3 color, float scale, float distribution, float rotation, bool random_opacity, bool random_rotation, bool multicolor){\n\n        vec2 st = gl_FragCoord.xy / u_resolution.x;\n\n        st *= u_resolution / scale; // Scale the coordinate system\n\n\n\n        vec2 ipos = floor(st);  // get the integer coords\n\n        vec2 fpos = fract(st);  // get the fractional coords\n\n        st = fpos;\n\n\n\n        // Use a matrix to rotate the space\n\n        if (random_rotation == true) {\n\n            rotation = rand(ipos) * 360.;\n\n        }\n\n        st = rotate(st, rotation * PI/180.);\n\n\n\n        // opacity\n\n        float opacity = 1.0;\n\n        if (random_opacity == true) {\n\n            opacity = rand(ipos * u_random_seed);\n\n        }\n\n\n\n        // amount of visible fragments\n\n        float amt = hash3D(hash3D(ipos).xy).x;\n\n\n\n        // vignette\n\n        vec2 center = vec2(u_resolution / scale*0.5 - 0.5);\n\n        float dist = distance(ipos,center);\n\n        float v = (1.0 - (dist/center.x*(u_vignette)));\n\n        opacity *= pow(v,20.);\n\n\n\n        // random color\n\n        if (u_color_random == true){\n\n            color = hash3D(ipos);\n\n        }\n\n\n\n        // shape\n\n        float shape = 1.;\n\n        \n\n        // square\n\n        if(u_shape[0]){\n\n            gl_FragColor = vec4(vec3(color),step(1.0 - distribution,amt) * opacity);\n\n        }\n\n\n\n        // circle\n\n        if(u_shape[1]){\n\n            shape = fill(circleSDF(st),1.0);\n\n            gl_FragColor = vec4(vec3(color),step(1.0 - distribution,amt) * opacity * shape);\n\n        }\n\n\n\n        // triangle\n\n        if(u_shape[2]){\n\n            shape = fill(triSDF(st),1.0);\n\n            gl_FragColor = vec4(vec3(color),step(1.0 - distribution,amt) * opacity * shape);\n\n        }\n\n\n\n        // diamond\n\n        if(u_shape[3]){\n\n            shape = fill(rectSDF(rotate(st,45. * PI/180.),vec2(0.71)),1.0);\n\n            gl_FragColor = vec4(vec3(color),step(1.0 - distribution,amt) * opacity * shape);\n\n        }\n\n\n\n        // line\n\n        if(u_shape[4]){\n\n            shape = fill(lineSDF(st,vec2(1.0),vec2(0.0)),(u_resolution.x / scale)*0.001);\n\n            gl_FragColor = vec4(vec3(color),step(1.0 - distribution,amt) * opacity * shape);\n\n        }\n\n\n\n        // cross\n\n        if(u_shape[5]){\n\n            shape = fill(crossSDF(st,1.0),1.0);\n\n            gl_FragColor = vec4(vec3(color),step(1.0 - distribution,amt) * opacity * shape);\n\n        }\n\n\n\n        // image\n\n        if(u_shape[6]){\n\n            float vis = aspectScale(st, u_shape_image_resolution.x, u_shape_image_resolution.y);\n\n            vec4 image = vec4(1.0);\n\n            image = texture2D(u_shape_image, st);\n\n            image.a *= step(1.0 - distribution,amt) * vis * opacity;\n\n            gl_FragColor = image;\n\n        }\n\n        \n\n    }\n\n\n\n    void main() {\n\n        staticNoise(u_color, u_size, u_amount, u_rotation, u_opacity_random, u_rotation_random, u_color_random);\n\n    }\n\n",
    "vertexShader": "\n            void main() {\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }"
  }